# 다층 퍼셉트론으로 손글씨 데이터 학습

Tech Stack: Pytorch, Sklearn
수정날짜: 2021년 7월 23일 오후 10:22
작성날짜: 2021년 7월 22일 오후 12:49

# 1. sklearn

머신러닝 관련 패키지로, 이 패키지를 사용해 학습에 이용될 데이터를 구한다.

```python
%matplotlib inline
import matplotlib.pyplot as plt # 시각화를 위한 맷플롯립
from sklearn.datasets import load_digits
import torch
import torch.nn as nn
from torch import optim
digits = load_digits() # 1,979개의 이미지 데이터 로드
```

```python
print(digits.images[0])
print(digits.target[0])
print(digits.data[0])
```

```python
[[ 0.  0.  5. 13.  9.  1.  0.  0.]
 [ 0.  0. 13. 15. 10. 15.  5.  0.]
 [ 0.  3. 15.  2.  0. 11.  8.  0.]
 [ 0.  4. 12.  0.  0.  8.  8.  0.]
 [ 0.  5.  8.  0.  0.  9.  8.  0.]
 [ 0.  4. 11.  0.  1. 12.  7.  0.]
 [ 0.  2. 14.  5. 10. 12.  0.  0.]
 [ 0.  0.  6. 13. 10.  0.  0.  0.]]
0
[ 0.  0.  5. 13.  9.  1.  0.  0.  0.  0. 13. 15. 10. 15.  5.  0.  0.  3.
 15.  2.  0. 11.  8.  0.  0.  4. 12.  0.  0.  8.  8.  0.  0.  5.  8.  0.
  0.  9.  8.  0.  0.  4. 11.  0.  1. 12.  7.  0.  0.  2. 14.  5. 10. 12.
  0.  0.  0.  0.  6. 13. 10.  0.  0.  0.]
```

images와 data는 데이터의 특성이다. images는 특성을 8x8 행렬로 표현하고 data는 64차원의 벡터로 표현한다. target은 데이터의 레이블을 나타낸다.

```python
images_and_labels = list(zip(digits.images, digits.target))
for index, (image, label) in enumerate(images_and_labels[:5]): # 5개의 샘플만 출력
    plt.subplot(2, 5, index + 1)
    plt.axis('off')
    plt.imshow(image, cmap=plt.cm.gray_r, interpolation='nearest')
    plt.title('sample: %i' % label)
```

![%E1%84%83%E1%85%A1%E1%84%8E%E1%85%B3%E1%86%BC%20%E1%84%91%E1%85%A5%E1%84%89%E1%85%A6%E1%86%B8%E1%84%90%E1%85%B3%E1%84%85%E1%85%A9%E1%86%AB%E1%84%8B%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%89%E1%85%A9%E1%86%AB%E1%84%80%E1%85%B3%E1%86%AF%E1%84%8A%E1%85%B5%20%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%20%E1%84%92%E1%85%A1%E1%86%A8%E1%84%89%E1%85%B3%E1%86%B8%207b20d3bea1ff4d0babedd2ea5fcaaa84/Untitled.png](%E1%84%83%E1%85%A1%E1%84%8E%E1%85%B3%E1%86%BC%20%E1%84%91%E1%85%A5%E1%84%89%E1%85%A6%E1%86%B8%E1%84%90%E1%85%B3%E1%84%85%E1%85%A9%E1%86%AB%E1%84%8B%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%89%E1%85%A9%E1%86%AB%E1%84%80%E1%85%B3%E1%86%AF%E1%84%8A%E1%85%B5%20%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%20%E1%84%92%E1%85%A1%E1%86%A8%E1%84%89%E1%85%B3%E1%86%B8%207b20d3bea1ff4d0babedd2ea5fcaaa84/Untitled.png)

상위 5개의 샘플을 출력해본다.

# 2. 학습

```python
X = digits.data # 이미지. 즉, 특성 행렬
Y = digits.target # 각 이미지에 대한 레이블
```

일단 X와 Y에 데이터의 특성과 레이블을 저장한다.

```python
model = nn.Sequential(
    nn.Linear(64, 32), # input_layer = 64, hidden_layer1 = 32
    nn.ReLU(),
    nn.Linear(32, 16), # hidden_layer2 = 32, hidden_layer3 = 16
    nn.ReLU(),
    nn.Linear(16, 10) # hidden_layer3 = 16, output_layer = 10
)
```

모델을 설계한다. data가 64차원 벡터였기 때문에 입력층은 64개의 독립변수를 입력으로 받는다. 활성화 함수로는 ReLU 함수를 사용하고, 은닉층은 2개로 설정한다.

따라서 층은 입력층, 은닉층1, 은닉층2, 출력층으로 총 4개가 존재한다.

```python
X = torch.tensor(X, dtype=torch.float32)
Y = torch.tensor(Y, dtype=torch.int64)
```

X와 Y는 현재 넘파이 행렬이므로 파이토치 텐서로 바꿔준다.

```python
loss_fn = nn.CrossEntropyLoss()
```

다중 클래스 분류 문제이므로 비용함수를 크로스 엔트로피 함수로 설정한다.

```python
optimizer = optim.Adam(model.parameters())
```

옵티마이저를 설정한다.

```python
for epoch in range(100):
  optimizer.zero_grad()
  y_pred = model(X) # forwar 연산
  loss = loss_fn(y_pred, Y)
  loss.backward()
  optimizer.step()
  if epoch % 10 == 0:
    print('Epoch {:4d}/{} Cost: {:.6f}'.format(
            epoch, 100, loss.item()
        ))
```

```python
Epoch    0/100 Cost: 3.109808
Epoch   10/100 Cost: 2.241030
Epoch   20/100 Cost: 2.017805
Epoch   30/100 Cost: 1.791625
Epoch   40/100 Cost: 1.534580
Epoch   50/100 Cost: 1.244356
Epoch   60/100 Cost: 0.970664
Epoch   70/100 Cost: 0.744902
Epoch   80/100 Cost: 0.575433
Epoch   90/100 Cost: 0.456974
```

학습