# KUCIS TIL

- 이름: 전호영

- 날짜: 21-07-26

### ⚙️ 오늘 공부한 내용

1. React Native

- live reloading
  - 코드 변경 후 저장하면 바로 변경사항이 저장됨.
- hot reloading
- 모바일 앱을 만드는 방법

  - 완전 native = Swift or objective-c 로 ios 앱 만들기 , Java or 코틀린으로 안드 앱 만들기
  - xcode / android studio ⇒ 네이티브
  - 앱 기반 웹뷰 만들기. ⇒ 앱 안 웹.
  - 리액트 네이티브 → js를 이용해 ios 네이티브 엔진에 메시지를 보냄. 브릿지라는 것을 사용해 안드, ios와 js를 이어줌.
  - 리액트 네이티브의 세상에선 모든게 View와 Text!

  ```jsx
  export default function App() {
    return (
      //  div -> View
      <View style={styles.container}>
        {/* span -> Text */}
        <Text>bye!</Text>
      </View>
    );
  }
  ```

  - StyleSheet API = css역할

  ```jsx
  // css 와 동일. react native에만 쓰임.
  const styles = StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: "white",
      alignItems: "center",
      justifyContent: "center",
    },
  });
  ```

  ex) css 추가할 때!

  ```jsx
  export default function App() {
    return (
      //  div -> View
      <View style={styles.container}>
        {/* span -> Text */}
        <Text style={styles.text}>bye!</Text>
      </View>
    );
  }

  // css 와 동일. react native에만 쓰임.
  const styles = StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: "black",
      alignItems: "center",
      justifyContent: "center",
    },
    text: {
      color: "white",
    },
  });
  ```

  ![스크린샷 2021-07-26 오전 1 27 04](https://user-images.githubusercontent.com/78394999/126937410-451051e0-25bc-4775-8870-39848bf8d5db.png)

  - 리액트 네이티브의 default flex direction은 컬럼이다.

  - flex: 1의 의미

  ```jsx
  export default function App() {
    return (
      //  div -> View
      <View style={styles.container}>
        {/* span -> Text */}
        <View style={styles.yellowView}></View>
        <View style={styles.blueView}></View>
      </View>
    );
  }

  // css 와 동일. react native에만 쓰임.
  const styles = StyleSheet.create({
    container: {
      flex: 1, // flex: 1 -> 할당 된 모든 공간 사용 가능!
    },
    yellowView: {
      flex: 1,
      backgroundColor: "yellow",
    },
    blueView: {
      flex: 1,
      backgroundColor: "blue",
    },
  });
  ```

  ![스크린샷 2021-07-26 오전 1 34 36](https://user-images.githubusercontent.com/78394999/126937609-7f8a407b-7abd-40aa-a3ef-e68a4e3e65a6.png)

  레이아웃을 잡는 건 최대한 flex를 이용해서 하기!

  그래야 어떤 기기를 사용하더라도 화면의 비율이 맞춰짐.

  - fontSize → px을 붙이면, string으로 써줘야 함! "20px"같은 느낌!
  - 현재 위치 받아오기.

  1.  웹 해킹.

  - 웹 아키텍쳐

  ![Untitled](https://user-images.githubusercontent.com/78394999/126937705-30b42c28-7d2c-4435-9899-df5f4f62974e.png)

  - HTTP ?
    - 주로 80포트를 사용해서 서비스
      - https:// 는 보안이 강화된 프로토콜이고, 기본 443포트를 사용.
    - 클라이언트의 HTTP요청과 서버의 HTTP응답으로 구성
    - HTTP 메소드 : GET(일반 웹페이지 요청), POST(글 쓰기, 값 변경 등..), PUT, DELETE 등..
    - 응답코드(status code)
      - 1XX : 정보전달
      - 2XX : 성공
      - 3XX : 리다이렉션
      - 4XX : 클라이언트 쪽 에러
      - 5XX : 서버 에러
    - HTTP는 상태정보유지 X → 세션 ID를 사용해 이전 상태 유지. → 세션 ID는 보통 '쿠키'로 전달 → 쿠키란 변수와 값의 쌍으로 구성. 클라와 서버 간 데이터 전송을 위해 이용됨.
    - 서버는 세션 ID를 받으면, 로그인을 한 것으로 유지
      - 세션 ID를 탈취해서 세션 하이재킹 공격을 할 수 있다는 말!!! (권한을 훔치는 것) (크로스 사이트 스크립트 공격의 주 목적)
  - HTTP 프록시

    - http 프록시 → 사용자와 웹서버 사이의 요청과 응답을 가로챈 후 내용을 수정할 수 있다.
    - 웹 해킹이나 웹 보안 취약점을 찾는데 유용.

    ![Untitled](https://user-images.githubusercontent.com/78394999/126937745-d58fc40b-4287-4bc8-a012-d08c5520d11b.png)

  - Burp Suite
    ![Untitled](https://user-images.githubusercontent.com/78394999/126937805-4abeeab5-c392-4a0f-bf45-edcd31ddc62c.png)

    127.0.0.1:8080 ⇒ 현재 로컬, 8080포트에서 돌아가고 있음.

    - 브라우저에서 프록시 잡아보기

![Untitled](https://user-images.githubusercontent.com/78394999/126937956-b862692a-d107-4b1a-9a82-38f01cb061b0.png)

브라우저에서 [localhost/dvwa/](http://localhost/dvwa/) 에 접속하면

![Untitled](https://user-images.githubusercontent.com/78394999/126937995-001c907c-bd1b-4ea2-9c73-e9ef74989d78.png)

http 요청 내용이 프록시에 잡힘.

Forward를 눌러서 리다이렉팅이 가능하게 하거나, Drop을 눌러 요청을 누락시킬 수 있다.

![Untitled](https://user-images.githubusercontent.com/78394999/126938053-993db509-49db-4eda-96ab-b53fe56c8ff0.png)

프록시 history 로그를 보면 각 로그에 대한 request와 response를 볼 수 있다.

response에서 Server에 나와있는 정보를 보면 아파치서버, php를 사용하고 있다는 정보를 얻을 수 있다. 보안을 중요시하는 기업들의 경우 server내용을 변경하거나 삭제하기도 함.

- DVWA란?
  - 웹해킹을 실습할 수 있도록 제작된 애플리케이션
- 브루트포스 공격

  - 사용자 패스워드 알아내기 위함.
  - 전부 대입
    - 알파벳 순
    - 딕셔너리 공격
  - 버프스위트를 통한 자동 브루트포스공격
    - 인터셉트 기능은 실시간으로 내용을 변조할 때 이외엔 꺼두는게 좋다.
    1. DVWA에서 아이디와 패스워드 입력
    2. 버프 스위트 프록시 http history에서 가장 최근 로그를 찾는다.
    3. dvwa 로그인 로그를 선택해 intruder로 보냄.
    4. intruder 로그에 쿼리스트링을 clear해주고 password 부분만 add해줌 (ex) $1234$)
    5. Payloads에서 type을 Brute forcer로 변경 후 원하는 길이와 문자, 숫자 등을 입력한 후 공격하면 됨.
    6. 응답 메시지의 길이가 달라졌다 → 비밀번호를 알아냈다! 라고 볼 수 있음.
  - 딕셔너리 공격

    - 터미널 gedit /usr/share/john/password.lst 입력
    - 딕셔너리 파일에 저장되어 있는 (통계적으로 많이 쓰임) 패스워드를 사용함.

    1. Payloads type을 simple list로 변경.
    2. 비밀번호 딕셔너리 파일을 load에서 연다.
    3. 공격 후 응답 길이 확인

  - 브루트 포스 공격 대응
    1. 비밀번호가 틀렸을 경우, 응답을 조금 느리게 보내거나, 응답 시간을 랜덤하게 보내 브루트 포스 공격 시간을 느려지게 함.
    2. 비밀번호 횟수 제한을 걸어둠. (Locking)
       1. 그러나 사용자가 자주 틀려서 피해를 볼 수 있다.
    3. Captcha 사용

1. nodeJs

   - 서버란?

     - 항상 켜져있고, 인터넷에 연결되어 있으며, request를 듣는 것.
       - request란 브라우저에게 내가 요청하는 것.
     - port를 사용해 요청을 듣는데 왜 port가 필요할까?

       → 서버는 컴퓨터 전체를 다 listen할 수 없으므로, 특정 request는 특정 port가 받도록 해주는 것.

     ```jsx
     import express from "express";

     const PORT = 4000;

     const app = express(); // express app 생성 후 코드를 작성해줘야 request에 대한 응답을 할 수 있다.

     // 아래 부터 Listen
     const handleListening = () =>
       console.log(`✅ Server listening on Port http://localhost:${PORT} 💫`);

     app.listen(4000, handleListening);
     ```

   - request를 전달하는 방법 ⇒ url사용.

     →ex) [http://localhost:4000/](http://localhost:4000/)login or [http://localhost:4000/](http://localhost:4000/)1235

   - 어딘가로 향하는 문의 역할 ! /login , /1235, /main etc

     →위와 같이 어딘가로 향하는 문을 route이라 부른다!

   - http GET ?
     - 사실 내가 웹사이트에 가는 것이 아니라, 웹사이트가 나한테 오는 것.
       - 내가 request를 하면, 서버가 response를 나의 브라우저로 보내줌.
       - 우리는 계속 받기만 한다! 얻어온다! → get
     - get(path, handler) 두개 필요!

### ⚙️ 회고(내일 할 일)

- 디자인 괜찮은 페이지 몇개 찾아보기
- 커맨드인젝션공격 공부
- react 훅스/ 라우터 공부.
