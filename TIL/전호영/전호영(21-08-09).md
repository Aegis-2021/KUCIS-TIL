# KUCIS TIL

- 이름: { 이름을 입력해주세요. }

- 날짜: { 날짜를 입력해주세요. ex) 21-07-01 }

### ⚙️ 오늘 공부한 내용

1. 슬랙 클론

- useSWR

  → revalidate 와 mutate의 차이

  - revalidate는 서버로 요청을 다시 보내 데이터를 갖고오는 것.

  - mutate는 서버에 요청을 보내지 않고 data를 수정하는 것.

1. revalidate

```tsx
const { data, error, revalidate } = useSWR(
  "http://localhost:3095/api/users/",
  fetcher
);
const handleClick = useCallback((e) => {
  e.preventDefault();
  axios
    .post("http://localhost:3095/api/users/logout", null, {
      withCredentials: true,
    })
    .then((res) => {
      revalidate();
    });
}, []);
```

b. mutate

```tsx
const { data, error, revalidate, mutate } = useSWR(
  "http://localhost:3095/api/users/",
  fetcher
);
const handleClick = useCallback((e) => {
  e.preventDefault();
  axios
    .post("http://localhost:3095/api/users/logout", null, {
      withCredentials: true,
    })
    .then((res) => {
      mutate(res.data, false);
    });
}, []);
```

- Optimistic UI

  - 일단 요청 성공할 것이라 생각하고 front를 변경 후 서버에 확인 요청을 하는 것.

  ```tsx
  const { data, error, revalidate, mutate } = useSWR(
    "http://localhost:3095/api/users/",
    fetcher
  );
  const handleClick = useCallback((e) => {
    e.preventDefault();
    axios
      .post("http://localhost:3095/api/users/logout", null, {
        withCredentials: true,
      })
      .then((res) => {
        mutate(res.data, true);
      });
  }, []);
  ```

  mutate(data, true)로 바꿔주면 됨! true!!

  false일 경우엔 서버에 확인요청을 보내지 않고 로컬데이터를 그대로 수정하는 것.

- gravatar

  - 랜덤 아이콘 생성해줌
  - npm i gravatar
  - npm i @types/gravatar

    → @types 가 필요한 패키지인지 확인하는 법 → 공식문서 (npm) 들어가서 패키지 확인해보기. (DT)표시 있으면 @types 깔아야함.

  ```tsx
  import gravatar from "gravatar";

  <ProfileImg
    src={gravatar.url(data.email, { s: "20px", d: "retro" })}
    alt={data.email}
  />;
  ```

- 토글 함수

```tsx
const [showUserMenu, setShowUserMenu] = useState(false);

const handleClickUserProfile = useCallback(() => {
  setShowUserMenu((prev) => !prev);
}, []);
```

- stopPropagation = 이벤트 버블링 방지.

→ 나를 선택하면 이벤트가 발생하지 않지만, 부모를 선택해야 이벤트가 실행되도록 하는 것!

→ 부모 태그로 이벤트 버블링이 일어나지 않는다.

1. C언어

- #include <stdlib.h> 필수!
- Memory Allocaton -> 메모리 할당.

  →내가 필요한 만큼만 메모리를 쓰겠다! 메모리 관리의 효율성.

- 메모리를 직접 이용하므로 포인터형 변수가 필요함

```c
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    int i;
    int n = 0;
    int *student = NULL;

    printf("학생의 수 : ");
    scanf("%d", &n);

    student = malloc(n * sizeof(int));
    for(i = 0; i < n; i++){
        int input;
        printf("%d번 학생의 점수를 입력 : ", i+1);
        scanf("%d", &input);
        student[i] = input;
    }

    for(i = 0; i < n; i++) {
        printf("%d번 학생의 점수 : %d\n", i + 1, student[i]);
    }

		free(student);

    return 0;
}
```

- malloc으로 메모리의 크기를 할당했으면, 해제도 해줘야 함! → free()

malloc이 항상 할당에 성공할까?

→ ㄴㄴ. 너무나 큰 메모리를 요구할땐 할당에 실패할 수 있다.

→ 할당 후, 제대로 할당이 되었는지 확인하는 절차가 필요함!

```c
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    char *p = NULL;
    int n = 0;
    printf("메모리 크기 : ");
    scanf("%d", &n);
    p = malloc(n);

    if(p == NULL)
        printf("malloc 할당 오류 발생.\n");
    else {
        p[0] = 0;
        free(p);
        p =  NULL; // 혹시 모를 버그 방지.
    }

    return 0;
}
```

1. kucis 회의

   가능하다면, 메일별로 안전한지 이상한지 알 수 있도록 확률에 따라 색으로 보여줌

   ex) 안전 = 초록색, 애매함 = 주황색, 위험 = 빨간색.

   → 메일 별 확률을 받아오면, 확률에 따라 메일 옆에 색을 보여주게 하기. (useEffect를 통해 메일함의 메일이 바뀔때 마다 새로 rendering하기.)

   grammarly가 좋은 예시.

- 메일 읽기 => 사이트로 불러오기 / 사이트로 가기

  메일 삭제 시 들어갈 휴지통 => 네이버 메일로 가지 않고 만든 사이트에서 연동해 삭제(직접가지않고 삭제)

- 영어로 들어온 메일을 자동번역 시켜주는 앱

  → 구글 번역 api

### ⚙️ 회고
