# KUCIS TIL

- 이름: 전호영

- 날짜: 21-08-02

### ⚙️ 오늘 공부한 내용

1. Slack (Reatc + TS)

- 타입정의가 필요할 때, 특히 어떤 타입이 들어올지 모를 때 두가지 선택지
  1. any
  2. T(Generic) → 이게 더 좋음
     - 타입을 변수로 만들어서, 리턴 값도 그냥 정해지도록 만든다!
- 컴포넌트 하나에만 쓰이는 비동기의 경우 분리할 필요가 없다.

  ```tsx
  const onSubmit = useCallback(
    (e) => {
      e.preventDefault();
      if (!mismatchError) {
        console.log("서버로 회원가입 하기");
        axios
          .post("http://localhost3095/api/users", { email, nickname, password })
          .then((res) => {
            console.log(res);
          }) // 요청 성공 시
          .catch((err) => {
            console.log(err.res);
          }) // 요청 실패 시
          .finally(() => {}); // 실패해도 실행되는, 무조건 실행해야 하는 것!
      }
    },
    [email, nickname, password, passwordCheck]
  );
  ```

  로그인 하는 과정!

  - finally() = 성공 | 실패 상관없이 실행되어야 하는 것!
  - 비동기 안에서 useState를 사용할 때는, 비동기 코드에 들어가기전 useState를 초기화 해주는 것이 좋다.
    - 요청 을 연달아 날릴 때, 첫 번째 요청 시 남아있던 결과가 두 번째 요청에서 나오는 경우가 있다.

- React router에서 <Link to=""></Link>를 사용하는 이유 !

  → a 태그는 화면이 바뀌면서 리프레시 되지만, Link to는 화면이 바뀔 때 기존 페이지가 리프레시 되지 않음! (화면 깜빡임이 없다.

- swr?

  - 프론트 입장에서 내가 로그인에 성공했다는 것을 알 수 있는 방법.

    → 로그인 - 데이터 저장,

    → 로그아웃 - 데이터 삭제

  - swr - get요청을 전역으로 저장.
  - npm i swr
  - swr은 로딩 상태 역시 알 수 있다.

    → 데이터가 존재하지 않으면 로딩중...

  - swr은 사용자가 다른 탭에 있다가 swr이 적용된 페이지로 돌아오면, 새로 get요청을 보내서 페이지를 실시간으로 유지시켜준다.

  ```tsx
  import useSWR from 'swr';
  import fetcher from '@utils/fetcher';

  const {data} = useSWR('http://localhost:3095/api/users/', fetcher);
  // useSWR 은 url을 fetcher함수로 전달해주는 역할.
  // fetcher함수가 url을 어떻게 처리할지 결정.
  // fetcher에서 return한 res.data가 {data} 속에 들어감!
  ----------------------------------------
  (fetcher.ts)
  import axios from 'axios';

  const fetcher = (url) =>
    axios.get(url, { withCredentials: true }).then((res) => {
      res.data;
    });
  //post에선 { withCredentials: true }가 3번째에 위치한다.
  export default fetcher;
  ```

- { withCredentials: true } ⇒ 백엔드와 프론트엔드의 쿠키공유.
  - cf) 쿠키의 생성 = 백엔드, 쿠키를 보냄 = 프론트엔드
- 로그아웃 원리
  - 쿠키에서 (언어별로 다르지만.. (spring에선 jsession id)) connect되어있는 부분을 삭제하면 됨.
  - 로그인 → connect 생성.
- 프론트해커 막기.
  - dedupingInterval
  - useSWR의 revalidate함수

1. C언어

# 2. 포인터와 배열의 관계

- 배열의 이름 = 상수 형태의 포인터

```c
#include <stdio.h>

int main(void)
{
    int arr[3] = {0, 1, 2};
    printf("배열의 이름 : %p \n", arr);
    printf("첫 번째 요소 : %p \n", &arr[0]);
    printf("두 번째 요소 : %p \n", &arr[1]);
    printf("세 번째 요소 : %p \n", &arr[2]);
    return 0;
}

result )
배열의 이름 : 0x16fdff418
첫 번째 요소 : 0x16fdff418
두 번째 요소 : 0x16fdff41c
세 번째 요소 : 0x16fdff420
```

- 배열의 이름은 배열의 시작 주소 값을 의미하며, 그 형태는 값의 저장이 불가능한 상수이다.

```c
int arr1[5] // arr1은 int형 포인터 상수
double arr2[7] // arr2는 double형 포인터 상수
```

→ 1차원의 배열이름의 포인터 형은 배열의 이름이 가리키는 대상을 기준으로 결정.

### 포인터를 배열의 이름처럼 사용할 수 있다!

```c
#include <stdio.h>

int main(void)
{
    int arr[3] = {15, 25, 35};
    int * ptr = &arr[0];

    printf("ptr[0] = %d , arr[0] = %d \n", ptr[0], arr[0]);
    printf("ptr[1] = %d , arr[1] = %d \n", ptr[1], arr[1]);
    printf("ptr[2] = %d , ptr[2] = %d \n", ptr[2], arr[2]);
    printf("*ptr = %d , *arr = %d \n", *ptr, *arr);
    return 0;
}

result

ptr[0] = 15 , arr[0] = 15
ptr[1] = 25 , arr[1] = 25
ptr[2] = 35 , ptr[2] = 35
*ptr = 15 , *arr = 15
```

- 포인터를 대상으로 n 증감연산 ⇒ n \* sizeof(포인터 자료형)의 크기
- 포인터 그 자체를 증감하는 것은, 주소를 바꾸는 것

cf)

- \*(++ptr) = 20; → ptr에 저장된 값 자체를 변경.
- \*(ptr+1) = 20; → ptr에 저장된 값은 변경되지 않음.

1. 예전 리액트 복습

   - 폴더구조
     - pages = 페이지 (진입.)
     - components = 컴포넌트
     - layouts = 페이지들 간 공통 레이아웃

   ```tsx
   <Route path="/day/:id">
   ```

   → day의 값이 id변수로 들어감

   if) day == 1 → id == 1

   - REST API란?
     - uri 주소와 method를 통해 crud 요청을 하는 것.
       - Create : POST
       - Upday : PUT
       - Read : GET
       - Delete : DELETE

### ⚙️ 회고(내일)

- voca 복습
- 검색 알고리즘
- slack 클론
